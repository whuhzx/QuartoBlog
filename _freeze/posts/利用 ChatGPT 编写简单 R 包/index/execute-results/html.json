{
  "hash": "636761d1fc5efeb5ffbdc05864d996bd",
  "result": {
    "markdown": "---\ntitle: \"利用 ChatGPT 编写简单 R 包\"\nauthor: \"Boyce\"\ndate: '2023/08/12'\ncategories: [R, ChatGPT]\nexecute: \n  eval: false\n---\n\n\n## 背景介绍\n\n很久之前就想创建一个R包，便于在做数据分析的时候根据个人需求复用函数，但因为觉得相关文档太复杂而放弃了。\n\n这次试了试用ChatGPT来帮助编写，发现过程还是比较简单的。虽然也花时间扫了一遍Hadley Wickham编写的[《R Package》](https://r-pkgs.org/)，但是有ChatGPT的帮助，能够对书中的内容和底层的机制有更清楚地了解。\n\n这里简单记录一下过程。为了方便起见，编写的R包里只有一个函数。\n\n## 准备\n\n事先需要安装两个服务于R包开发的package，分别是`devtools`和`roxygen2`，后者主要用于自动生成包的帮助文档。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(devtools)\nlibrary(roxygen2)\n```\n:::\n\n\n在Rstudio中新建项目，并选择`R Package`，就会自动生成一个工程文件夹。文件目录大致如下：\n\n\n::: {.cell}\n\n```{.default .cell-code}\nmyutils/\n|-- DESCRIPTION #描述文件，内容包括基本信息，如包的名称、版本、作者、描述、依赖等\n|-- NAMESPACE #文件指定了哪些函数或对象应该被导出（用户可以直接访问）以及哪些其他的包的函数应该被导入 \n|-- R/ #在目录中放置所有的R函数代码\n|   |-- function1.R\n|   |-- function2.R\n|-- man/ #在目录中放置函数的帮助文档。这些文件通常使用roxygen2注释在R文件中自动生成。\n|   |-- function1.Rd\n|   |-- function2.Rd\n|-- data/ #目录用于存放包中的数据集\n|   |-- dataset1.RData\n|-- inst/ #存放不适合其他类别的文件。\n|   |-- extdata/\n|   |   |-- some_additional_data.csv\n|-- tests/ #放置测试代码，通常使用testthat包来编写测试，此次不涉及\n|   |-- testthat/\n|   |   |-- test_function1.R\n|   |   |-- test_function2.R\n|-- vignettes/ #存放包的使用教程或详细文档\n|   |-- introduction.Rmd\n|-- LICENSE\n```\n:::\n\n\n\n## 填写DESCRIPTION文件\n\n在DESCRIPTION文件中填入包的基本信息。\n\n如果R包需要引入外部package，需要在文件中加入Imports依赖，这里我们编写的函数需要引入tidyverse和tidytext两个包。\n\n\n::: {.cell}\n\n```{.default .cell-code}\nPackage: myutils\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true # 包中如果含有数据集，true表示library()不加载数据集，使用到数据集时才加载\nImports: \n    tidyverse,\n    tidytext\n```\n:::\n\n\n\n## 添加函数\n\n这里添加一个我常使用的计算TGI的函数`compute_tgi_top_n`。\n\n`#'`后面填上函数的介绍，`#' @param`后面则是每个参数的含义，后续roxygen2会根据注释在R文件中自动生成帮助文件。\n\n`#' @export`表示这个函数可以被外部调用，如果不加入这个注释，表明只供内部使用，外部使用者在`library(myutils)`加载包后无法使用该函数。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Compute dataset TGI\n#' @param x 数据集\n#' @param target 目标对象\n#' @param category 分组类型\n#' @param tgi_value 数值\n#' @param top_number 最大排名\n#' @export\ncompute_tgi_top_n <- function(x, target, category, tgi_value, top_number = 10){\n  x %>%\n    group_by(!!sym(target), !!sym(category)) %>%\n    summarise(value = sum(!!sym(tgi_value))) %>%\n    ungroup() %>%\n    mutate(total = sum(value)) %>%\n    group_by(!!sym(target)) %>%\n    mutate(target_ratio = value / sum(value)) %>%\n    ungroup() %>%\n    group_by(!!sym(category)) %>%\n    mutate(total_ratio = sum(value) / total) %>%\n    mutate(tgi = round(target_ratio / total_ratio * 100, 0)) %>%\n    ungroup() %>%\n    arrange(desc(tgi)) %>%\n    group_by(!!sym(target)) %>%\n    top_n(top_number, tgi) %>%\n    ggplot(aes(x = tgi, y = reorder_within(!!sym(category), tgi, !!sym(target)))) +\n    geom_col() +\n    geom_text(aes(label = tgi)) +\n    facet_wrap(vars(!!sym(target)), scale = \"free\") +\n    scale_y_reordered() +\n    theme(text = element_text(family = \"PingFang SC\"))\n}\n```\n:::\n\n\n## 添加数据集\n\n如果要在开发的包中加入固定数据集以供后续载入调用，可以将数据集放置在data目录下。\n\n根据[《R Pacakge》](https://r-pkgs.org/data.html)一书，数据集的最佳保存格式为`.rda`。可以使用`save(my_data, file = \"my_data.rda\")`将数据集保存为该格式，或者使用`usethis::use_data(my_data)`自动保存。\n\n## 生成文档\n\n执行`roxygenise()`后，会在man目录下生成一个名为`compute_tgi_top_n.Rmd`的文件，里面是该函数的帮助文档。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetwd(\"path_to_myutils\")  # 将包的项目路径设置为工作目录\nroxygen2::roxygenise()\n```\n:::\n\n\n执行`roxygenise()`后发生了什么？以下是ChatGPT给出的回答。\n\n\n::: {.cell}\n\n```{.markdown .cell-code .code-overflow-wrap}\n- 解析roxygen注释：函数会检查你的R源代码文件，寻找以#'开始的roxygen注释。\n\n- 生成.Rd文件：对于源代码中的每个函数、类或数据集，roxygenise()会在man/目录中生成一个.Rd文件。这些文件为R包中的每个公共对象提供手册页。\n\n- 更新NAMESPACE文件：基于roxygen注释中的@export、@import、@importFrom等标签，NAMESPACE文件会被自动更新。例如，如果你在函数上方有#' @export注释，该函数将被导出，允许用户在加载包后直接访问它。\n\n- 生成vignettes：如果你在包中包含了vignettes（即长格式的文档或教程），并且使用roxygen2标签为它们编写了元数据，那么roxygenise()也会处理这些vignettes。\n\n- 其他文档更新：roxygen2也支持许多其他标签，这些标签可以帮助生成数据集的文档、包的描述和其他文档部分。\n```\n:::\n\n\n## 将包安装到本地库中\n\n使用devtools包内置的`install()`函数，就能够将包安装到本地库中，方便后续直接用`library()`调用。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install(\"myutils\")\n```\n:::\n\n\n执行`install()`后发生了什么？ChatGPT给出了如下答案，有助于理解包安装背后的机制。\n\n\n::: {.cell}\n\n```{.markdown .cell-code .code-overflow-wrap}\n- 构建：首先，R会将你的包的所有文件打包成一个.tar.gz文件（在Linux和Mac上）或.zip文件（在Windows上）。这个文件是R包的源代码格式。\n\n- 检查包的依赖关系：install()会查看myutils包的DESCRIPTION文件，找到任何在Depends、Imports或LinkingTo字段中列出的依赖关系。如果这些依赖的包还没有被安装，install()通常会尝试自动安装它们。\n\n- 编译：如果你的包包含任何C、C++或Fortran代码，R会尝试编译这些代码。这需要有合适的编译工具链。例如，在Windows上，你可能需要Rtools来编译C或C++代码。\n\n- 安装：一旦包被构建并编译（如果需要的话），它就会被安装到R的库中。这实际上就是将包的所有文件复制到R的包目录，通常是library/目录。\n\n- 加载：安装后，你可以使用library(myutils)命令加载并使用你的包。\n\n- 二进制包：在某些系统上，例如Windows，install()可能还会为你的包创建一个二进制版本，这样在未来安装包时可以更快。\n```\n:::\n\n\n接下来就可以在本地加载`library(myutils)`后调用`compute_tgi_top_n()`函数了。也可以通过`?compute_tgi_top_n`来查看帮助文档。\n\n## 将包上传到Github上\n\n最后，我们进入包目录，将本地包初始化并新做一个版本。\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit init\ngit add .\ngit commit -m \"first package version\"\n```\n:::\n\n\n在个人Github主页上新建一个库。然后，将本地库和远程库建立关联。\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit remote add origin git@github.com:your_username/myutils.git\n\n# 若显示远程库已存在，则加上set-url更新一下\ngit remote set-url origin git@github.com:your_username/myutils.git\n```\n:::\n\n\n将本地库推送到Github上。\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# 重命名当前活动分支为main\ngit branch -M main\n\n# 将main分支推送到名为origin的远程仓库，并设置上游追踪关系\ngit push -u origin main\n```\n:::\n\n\n推送完成，之后可以在任何电脑上使用`install_github()`命令来安装这个R包啦。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"your_username/myutils\")\n```\n:::\n\n\n## 相关资源\n\n- [《R Packages》](https://r-pkgs.org/)\n\n- [为新手准备的现代化 R 包开发流程](https://mp.weixin.qq.com/s/Q_chMLju5YEIFncWJ2GFlw)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}