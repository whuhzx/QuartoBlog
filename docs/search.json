[
  {
    "objectID": "posts/常用包和函数汇总/index.html",
    "href": "posts/常用包和函数汇总/index.html",
    "title": "R 常用包和函数汇总",
    "section": "",
    "text": "数据集摘要：gtExtras::gt_plt_summary()，展现每个变量的描述性统计指标，并用可视化的方式展现变量的分布。\n\n\n\n列名清洗： janitor::clean_names()，将命名不一致的列名统一规范化。"
  },
  {
    "objectID": "posts/常用包和函数汇总/index.html#数据可视化",
    "href": "posts/常用包和函数汇总/index.html#数据可视化",
    "title": "R 常用包和函数汇总",
    "section": "数据可视化",
    "text": "数据可视化\n\nhrbrthemes\nggplot 主题风格拓展，使用方法可见 hrbrthemes：最好用的 ggplot 主题扩展包。\n\n\ngghighlight\n帮助高亮图表，使用方法可见使用 gghighlight 制图。\n\n\nwaffle\n华夫饼图绘制包，使用方法可见使用 waffle package 制作华夫饼图。\n\n\nggalluvial\n桑基图和凹凸图绘制包，使用方法可见使用 ggalluvial 制作桑基图和凹凸图。\n\n\nggwordcloud\n用 ggplot 语法绘制词云，使用方法可见ggwordcloud: a word cloud geom for ggplot2及R Charts: Word cloud in ggplot2 with ggwordcloud。\n\n\npatchwork\n快速组合不同图表：p1 + p2。使用方法详见教程。"
  },
  {
    "objectID": "posts/hrbrthemes：最好用的ggplot主题扩展包/index.html",
    "href": "posts/hrbrthemes：最好用的ggplot主题扩展包/index.html",
    "title": "hrbrthemes：最好用的 ggplot 主题扩展包",
    "section": "",
    "text": "ggplot 好用归好用，但是默认主题给人的感觉还是过于呆板，一直想找一个比较美观的 ggplot 主题拓展包。\n恰好看到 Awesome ggplot2 有收集 ggplot 的主题拓展，遂逐一尝试了一下。\n经过筛选，发现只有 hrbrthemes 满足自己的要求：第一，风格简约，足够美观；第二，语法与 ggplot2 保持一致，符合使用习惯。"
  },
  {
    "objectID": "posts/hrbrthemes：最好用的ggplot主题扩展包/index.html#使用方法",
    "href": "posts/hrbrthemes：最好用的ggplot主题扩展包/index.html#使用方法",
    "title": "hrbrthemes：最好用的 ggplot 主题扩展包",
    "section": "使用方法",
    "text": "使用方法\n\n# 包引入\nlibrary(tidyverse)\nlibrary(hrbrthemes)\nlibrary(datasets)\nlibrary(patchwork) #控制多张图表的位置摆放\n\n使用 datasets package 内置的 airquality 数据集来做测试。\n\nknitr::kable(head(airquality))\n\n\n\n\nOzone\nSolar.R\nWind\nTemp\nMonth\nDay\n\n\n\n\n41\n190\n7.4\n67\n5\n1\n\n\n36\n118\n8.0\n72\n5\n2\n\n\n12\n149\n12.6\n74\n5\n3\n\n\n18\n313\n11.5\n62\n5\n4\n\n\nNA\nNA\n14.3\n56\n5\n5\n\n\n28\nNA\n14.9\n66\n5\n6\n\n\n\n\n\n\n内置主题函数\n\n# ggplot默认主题作图\nplot1 <- airquality %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point()\n\n# 使用hrbrthemes的默认主题作图\nplot2 <- airquality %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point() +\n  theme_ipsum()\n\n# 将两张图并列对比\nplot1 + plot2\n\n\n\n\n通过比较可以发现，theme_ipsum 将默认的背景色去掉了，并对横轴和纵轴的图例做了处理：将其字体变小，并将位置从中心处挪到边沿处。整体上变得更加简约和美观。\n使用 ?theme_ipsum 可以进一步看到该主题的内置参数，挑选几个比较重要的参数展示一下。\n1、grid 控制网格，默认是保留X轴和Y轴的网格，如需改变，可以直接使用 grid = '' 删除网格，或者使用 grid = 'X' 只保留X轴的网格。\n\nairquality %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point() +\n  theme_ipsum(grid = 'X')\n\n\n\n\n2、axis 控制横纵轴的起始轴线，默认是删除的，如果需要保留，使用方法和 grid 类似：\n\nairquality %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point() +\n  theme_ipsum(axis = 'XY')\n\n\n\n\n3、使用 base_family 控制字体。英文的主题风格，中文如果直接使用默认字体，效果一般不好。经过测试，苹果系统使用华文细黑 STXihei 字体的效果比较好。\n\nairquality %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point() +\n  labs(title = '散点图', x = '风速', y = '温度') +\n  theme_ipsum(base_family = 'STXihei')\n\n\n\n\n4、除了以上参数，theme_ipsum 主题函数还可以设置如下参数：标题 plot_title_、副标题 subtitle_、分面标题 strip_text_、注释 caption_、横纵坐标值 axis_title_等。\n5、除了 theme_ipsum，还有 theme_ipsum_es()、theme_tinyhand()、theme_ft_rc() 等主题风格。\n\nplot3 <- airquality %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point() +\n  labs(title = '散点图', x = '风速', y = '温度') +\n  theme_ft_rc(base_family = 'STXihei')\n\nplot4 <- airquality %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point() +\n  labs(title = '散点图', x = '风速', y = '温度') +\n  theme_ipsum_rc(base_family = 'STXihei')\n\nplot3 + plot4\n\n\n\n\n\n\n内置色彩系统\nhrbrthemes 也内置了色彩系统，方便直接调用。例如 scale_color_ipsum() 和 scale_color_ft()：\n\np5 <- airquality %>%\n  mutate(Month = as.factor(Month)) %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point(aes(color = Month)) +\n  scale_color_ipsum() +\n  theme_ipsum()\n\np6 <- airquality %>%\n  mutate(Month = as.factor(Month)) %>%\n  ggplot(aes(x = Wind, y = Temp)) +\n  geom_point(aes(color = Month)) +\n  scale_color_ft() +\n  theme_ipsum()\n\np5 + p6\n\n\n\n\n也可以使用 ipsum_pal() 和 ft_pal() 直接返回颜色编码字符串。\n\nscales::show_col(ipsum_pal()(9))\n\n\n\nscales::show_col(ft_pal()(9))"
  },
  {
    "objectID": "posts/hrbrthemes：最好用的ggplot主题扩展包/index.html#相关资源",
    "href": "posts/hrbrthemes：最好用的ggplot主题扩展包/index.html#相关资源",
    "title": "hrbrthemes：最好用的 ggplot 主题扩展包",
    "section": "相关资源",
    "text": "相关资源\n\nhrbrthemes Github page\nMan pages for hrbrthemes"
  },
  {
    "objectID": "posts/使用 waffle package 制作华夫饼图/index.html",
    "href": "posts/使用 waffle package 制作华夫饼图/index.html",
    "title": "使用 waffle package 制作华夫饼图",
    "section": "",
    "text": "今天制作的是华夫饼图，灵感参照自 bydata 的 #30DayChartChallenge。\n原始图片及使用 ggplot2 制图的最终效果如下：\n\n\n\n\n\n\n原始图片\n\n\n\n\n\n\n\n最终效果"
  },
  {
    "objectID": "posts/使用 waffle package 制作华夫饼图/index.html#包加载",
    "href": "posts/使用 waffle package 制作华夫饼图/index.html#包加载",
    "title": "使用 waffle package 制作华夫饼图",
    "section": "包加载",
    "text": "包加载\n\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(waffle)"
  },
  {
    "objectID": "posts/使用 waffle package 制作华夫饼图/index.html#导入数据",
    "href": "posts/使用 waffle package 制作华夫饼图/index.html#导入数据",
    "title": "使用 waffle package 制作华夫饼图",
    "section": "导入数据",
    "text": "导入数据\n\nraw_data <- read_xlsx(\"sdg_07_40_page_spreadsheet.xlsx\", sheet = 3, skip = 8, na = \":\") \n\n这里需要注意，原始数据中 missing data 使用 : 表示，因此需使用参数 na = \":\" 将 : 转换成 NA 。"
  },
  {
    "objectID": "posts/使用 waffle package 制作华夫饼图/index.html#数据清洗",
    "href": "posts/使用 waffle package 制作华夫饼图/index.html#数据清洗",
    "title": "使用 waffle package 制作华夫饼图",
    "section": "数据清洗",
    "text": "数据清洗\n\n# 对原始数据进行数据清洗\nclean_data <- raw_data %>%\n  # 过滤掉带有NA的行\n  drop_na() %>%\n  # 仅选择2020年的数据\n  select(Country = TIME, pct = `2020`) %>%\n  # 过滤掉国家名太长的国家（主要表示某个区域或者国家联盟）\n  filter(str_length(Country) <= 18) %>%\n  # 随机选择20个国家进行可视化\n  sample_n(20) %>%\n  mutate(pct = as.numeric(pct) %>% round(0)) %>%\n  # 按照比例从大到小排序\n  mutate(Country = fct_reorder(Country, -pct, sum)) %>%\n  mutate(reverse_pct = 100 - pct) %>%\n  pivot_longer(cols = pct:reverse_pct, names_to = 'type', values_to = 'value') %>%\n  mutate(value_pct = str_c(value, \"%\"))\n\n\nknitr::kable(head(clean_data))\n\n\n\n\nCountry\ntype\nvalue\nvalue_pct\n\n\n\n\nBulgaria\npct\n23\n23%\n\n\nBulgaria\nreverse_pct\n77\n77%\n\n\nLatvia\npct\n42\n42%\n\n\nLatvia\nreverse_pct\n58\n58%\n\n\nPoland\npct\n16\n16%\n\n\nPoland\nreverse_pct\n84\n84%"
  },
  {
    "objectID": "posts/使用 waffle package 制作华夫饼图/index.html#画图和调整",
    "href": "posts/使用 waffle package 制作华夫饼图/index.html#画图和调整",
    "title": "使用 waffle package 制作华夫饼图",
    "section": "画图和调整",
    "text": "画图和调整\n直接上代码：\n\nwaffle_plot <- clean_data %>%\n  ggplot(aes(fill = type, values = value)) +\n  geom_waffle(color = \"white\", size = 0.5, n_rows = 10) +\n  facet_wrap(~ Country, ncol= 5) +\n  # 横纵坐标轴的坐标和数值全部删除\n  scale_x_discrete(expand=c(0,0)) +\n  scale_y_discrete(expand=c(0,0)) +\n  guides(fill = 'none') +\n  # 横纵坐标比例相等，使得华夫饼图呈现为正方形\n  coord_equal() +\n  labs(\n    title = 'Share of renewable energy in gross final energy consumption (2020)',\n    caption = 'Source: European Environment Agency (EEA)'\n  ) +\n  theme(\n    strip.background = element_blank(),\n    # 分面标题加粗\n    strip.text = element_text(face = 'bold'))\n\n\n# 输出ggplot制图结果\nwaffle_plot\n\n\n\n\n经过 Figma 调整后的图片如下："
  },
  {
    "objectID": "posts/使用 waffle package 制作华夫饼图/index.html#注意事项",
    "href": "posts/使用 waffle package 制作华夫饼图/index.html#注意事项",
    "title": "使用 waffle package 制作华夫饼图",
    "section": "注意事项",
    "text": "注意事项\n如果遇到首次使用geom_waffle()函数报错，可以用如下方法解决：\n\nremotes::install_github(\"hrbrmstr/waffle\")\n关闭Rstudio后重新打开，问题解决\n解决方法来自https://github.com/hrbrmstr/waffle/issues/76"
  },
  {
    "objectID": "posts/使用 waffle package 制作华夫饼图/index.html#相关资源",
    "href": "posts/使用 waffle package 制作华夫饼图/index.html#相关资源",
    "title": "使用 waffle package 制作华夫饼图",
    "section": "相关资源",
    "text": "相关资源\n\nwaffle Github\nwaffle 官方文档\nR 使用 waffle 套件繪製鬆餅圖教學與範例"
  },
  {
    "objectID": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html",
    "href": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html",
    "title": "使用 ggalluvial 制作桑基图和凹凸图",
    "section": "",
    "text": "library(tidyverse)\nlibrary(ggalluvial)\nlibrary(hrbrthemes)\nlibrary(patchwork)"
  },
  {
    "objectID": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#数据准备",
    "href": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#数据准备",
    "title": "使用 ggalluvial 制作桑基图和凹凸图",
    "section": "数据准备",
    "text": "数据准备\n\n\n\n\nknitr::kable(head(city_data))\n\n\n\n\nfre_city_level\njob_city_level\ntotal\n\n\n\n\n一线城市\n一线城市\n58\n\n\n一线城市\n三线城市\n11\n\n\n一线城市\n二线城市\n17\n\n\n一线城市\n五线城市\n2\n\n\n一线城市\n四线城市\n3\n\n\n一线城市\n新一线城市\n56"
  },
  {
    "objectID": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#桑基图",
    "href": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#桑基图",
    "title": "使用 ggalluvial 制作桑基图和凹凸图",
    "section": "桑基图",
    "text": "桑基图\n先直接看个例子。\n\np1 <- city_data %>%\n  ggplot(aes(axis1 = fre_city_level, axis2 = job_city_level, y = total)) +\n  geom_alluvium(aes(fill = job_city_level)) +\n  geom_stratum() +\n  geom_text(stat = \"stratum\",\n            aes(label = after_stat(stratum)), family = 'STXihei') +\n  scale_x_discrete(expand = c(0,0), limits = c('投出简历次数', '接收简历次数')) +\n  scale_y_continuous(expand = c(0,0)) +\n  labs(x = '', y = '') +\n  guides(y = 'none', fill = 'none') +\n  theme_ipsum(base_family = \"STXihei\", grid = '') \n\np1\n\n\n\n\naxis 表示桑基图要流经的变量。例如现在我们要看不同线级城市之间的简历数量流动情况，则 axis1 = fre_city_level 表示简历从常驻线级城市流出；axis2 = job_city_level 表示流入到职位所在的线级城市。\ngeom_stratum() 是给流动变量做进一步分类，例如 fre_city_level 和 job_city_level 都被分为五个线级城市。另外，geom_text() 里 stat = \"stratum\" 和 label = after_stat(stratum) 是 ggalluvial 内置的固定用法，照着用即可。\ngeom_alluvium() 中，fill 参数控制的是流动线条的颜色。fill = job_city_level 表示我们以简历流入地为观察视角，看不同线级城市各流入了多少简历。这里也可以简历流出地为观察视角，只需要设置 fill = job_city_level 即可。\n\np2 <- city_data %>%\n  ggplot(aes(axis1 = fre_city_level, axis2 = job_city_level, y = total)) +\n  geom_alluvium(aes(fill = job_city_level), curve_type = \"linear\") +\n  geom_stratum() +\n  geom_text(stat = \"stratum\",\n            aes(label = after_stat(stratum)), family = 'STXihei') +\n  scale_x_discrete(expand = c(0,0), limits = c('投出简历次数', '接收简历次数')) +\n  scale_y_continuous(expand = c(0,0)) +\n  labs(x = '', y = '') +\n  guides(y = 'none', fill = 'none') +\n  theme_ipsum(base_family = \"STXihei\", grid = '') \n\np2\n\n\n\n\n基本用法之外，geom_alluvium() 函数还有一个 curve_type 参数，curve_type =  \"linear\" 表示线条使用直线。除了 linear，还有 cubic、cubic、quintic 等值，但是肉眼看不出太大区别。\n最后需要注意的是，制作桑基图时一般使用宽数据，操作如上所示。长数据也可，只是没有那么容易理解，这里不再演示。"
  },
  {
    "objectID": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#凹凸图",
    "href": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#凹凸图",
    "title": "使用 ggalluvial 制作桑基图和凹凸图",
    "section": "凹凸图",
    "text": "凹凸图\n在看文档的时候，意外发现 ggalluvial 不仅可以制作桑基图，还可以用来制作凹凸图。\n\n# 使用 alluvial package 内置的数据集 Refugees 做测试\ndata(Refugees, package = \"alluvial\")\n\nknitr::kable(head(Refugees))\n\n\n\n\ncountry\nyear\nrefugees\n\n\n\n\nAfghanistan\n2003\n2136043\n\n\nBurundi\n2003\n531637\n\n\nCongo DRC\n2003\n453465\n\n\nIraq\n2003\n368580\n\n\nMyanmar\n2003\n151384\n\n\nPalestine\n2003\n350568\n\n\n\n\n\n还是直接上个例子。\n\np3 <- Refugees %>%\n  ggplot(\n       aes(x = year, \n           y = refugees/10000, \n           alluvium = country)) +\n  geom_alluvium(aes(fill = country, colour = country), \n                alpha = .75, decreasing = FALSE) +  # decreasing一定要设置为FALSE\n  scale_x_continuous(breaks = seq(2003, 2013, 2)) +\n  theme_ipsum(grid = 'XY') +\n  scale_fill_brewer(type = \"qual\", palette = \"Set3\") +\n  scale_color_brewer(type = \"qual\", palette = \"Set3\") +\n  ggtitle(\"refugee volume by country and region of origin\")\n\np3\n\n\n\n\n上面的 x 轴是年份，y 轴是难民数量，alluvium 表示线条的类别，这里表示难民来自哪个国家。注意要把 geom_alluvium() 中的 decreasing 参数设置为 FALSE。\n另外 geom_alluvium 中的 width 参数表示不同年份变化中间的留白，width = 1 表示不需要任何留白，经试验，把值设置成 0.5 较为美观。\n\np4 <- Refugees %>%\n  ggplot(\n       aes(x = year, \n           y = refugees/10000, \n           alluvium = country)) +\n  geom_alluvium(aes(fill = country, colour = country),\n                alpha = .75, decreasing = FALSE,\n                width = 1) +  # decreasing一定要设置为FALSE\n  scale_x_continuous(breaks = seq(2003, 2013, 2)) +\n  theme_ipsum(grid = 'XY') +\n  scale_fill_brewer(type = \"qual\", palette = \"Set3\") +\n  scale_color_brewer(type = \"qual\", palette = \"Set3\") +\n  guides(fill = 'none', color = 'none') +\n  ggtitle(\"widht = 1\")\n\np5 <- Refugees %>%\n  ggplot(\n       aes(x = year, \n           y = refugees/10000, \n           alluvium = country)) +\n  geom_alluvium(aes(fill = country, colour = country),\n                alpha = .75, decreasing = FALSE,\n                width = 0.5) +  \n  scale_x_continuous(breaks = seq(2003, 2013, 2)) +\n  theme_ipsum(grid = 'XY') +\n  scale_fill_brewer(type = \"qual\", palette = \"Set3\") +\n  scale_color_brewer(type = \"qual\", palette = \"Set3\") +\n  guides(fill = 'none', color = 'none') +\n  ggtitle(\"width = 0.5\")\n\np4 + p5"
  },
  {
    "objectID": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#注意事项",
    "href": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#注意事项",
    "title": "使用 ggalluvial 制作桑基图和凹凸图",
    "section": "注意事项",
    "text": "注意事项\n\nstat_stratum()函数报错\n首次使用 stat_stratum() 函数为数据分类分层时，遇到报错： Computation failed in stat_stratum。\n在 ggalluvial 的 Github Issues 里找到了解决方法：将 dplyr 升级至 1.1.0 以后版本。\n\n\n流入地和流出地的分类类别不能完全一致\n在桑基图的例子中，流入地和流出地都是线级城市，分类类型完全一致，首次 run 的时候报错了。这里用了一个笨办法来解决：给标签重命名，即在X线城市前面加了个空格，在图表显示的时候看不出来。\n\ncity_data <- city_data %>%\n  mutate(fre_city_level = fct_relevel(fre_city_level, c(' 一线城市', ' 新一线城市', ' 二线城市', ' 三线城市', ' 四线城市', ' 五线城市')))"
  },
  {
    "objectID": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#相关资源",
    "href": "posts/使用 ggalluvial 制作桑基图和凹凸图/index.html#相关资源",
    "title": "使用 ggalluvial 制作桑基图和凹凸图",
    "section": "相关资源",
    "text": "相关资源\n\nggalluvial Github Page\nAlluvial Plots in ggplot2\nR Charts: Alluvial plot in ggplot2 with ggalluvial"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Boyce’s Blog",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n作图时如何正确渲染中文字体\n\n\n\n\n\n\n\nR\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nOct 11, 2023\n\n\nBoyce\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n文本可视化的一种方式：词语在两个数据集中的排名对比\n\n\n\n\n\n\n\nR\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nSep 9, 2023\n\n\nBoyce\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuarto 常用语法汇总\n\n\n\n\n\n\n\nQuarto\n\n\n清单\n\n\n\n\n\n\n\n\n\n\n\nAug 12, 2023\n\n\nBoyce\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n利用 ChatGPT 编写简单 R 包\n\n\n\n\n\n\n\nR\n\n\nChatGPT\n\n\nGithub\n\n\n\n\n\n\n\n\n\n\n\nAug 12, 2023\n\n\nBoyce\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用 gghighlight 制图\n\n\n\n\n\n\n\nR\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nAug 6, 2023\n\n\nBoyce\n\n\n\n\n\n\n  \n\n\n\n\n使用 geom_ribbon 给双折线区间填充颜色\n\n\n\n\n\n\n\nR\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nAug 4, 2023\n\n\nBoyce\n\n\n\n\n\n\n  \n\n\n\n\n在 Github 上部署 Quarto 的静态网页\n\n\n\n\n\n\n\nGithub\n\n\nQuarto\n\n\n\n\n\n\n\n\n\n\n\nMar 5, 2023\n\n\nBoyce\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR 常用包和函数汇总\n\n\n\n\n\n\n\nR\n\n\n清单\n\n\n\n\n\n\n\n\n\n\n\nMar 4, 2023\n\n\nBoyce\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhrbrthemes：最好用的 ggplot 主题扩展包\n\n\n\n\n\n\n\nR\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nFeb 25, 2023\n\n\nBoyce\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用 ggalluvial 制作桑基图和凹凸图\n\n\n\n\n\n\n\nR\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nFeb 23, 2023\n\n\nBoyce\n\n\n\n\n\n\n  \n\n\n\n\n使用 waffle package 制作华夫饼图\n\n\n\n\n\n\n\nR\n\n\nggplot2\n\n\n\n\n\n\n\n\n\n\n\nDec 7, 2022\n\n\nBoyce\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/在 Github 上部署 Quarto 的静态网页/index.html",
    "href": "posts/在 Github 上部署 Quarto 的静态网页/index.html",
    "title": "在 Github 上部署 Quarto 的静态网页",
    "section": "",
    "text": "简单记录一下，如何在 Github 上部署 Quarto 的静态网页。"
  },
  {
    "objectID": "posts/在 Github 上部署 Quarto 的静态网页/index.html#配置-quarto-项目文件夹并关联本地库和远程库",
    "href": "posts/在 Github 上部署 Quarto 的静态网页/index.html#配置-quarto-项目文件夹并关联本地库和远程库",
    "title": "在 Github 上部署 Quarto 的静态网页",
    "section": "配置 Quarto 项目文件夹，并关联本地库和远程库",
    "text": "配置 Quarto 项目文件夹，并关联本地库和远程库\n1、配置 Quarto 项目文件夹\n在 _quarto.yml 文件中写入 output-dir: docs，渲染后会生成 docs 目录，里面就是将要部署的静态网页。\n```{yaml}\nproject:\n  type: website\n  output-dir: docs\n```\n在主目录下使用 touch .nojekyll 新建 .nojekyll 文件，告诉 Github 在部署网页时，不要用默认的 Jekyll 处理网页。\n2、Quarto 的 Git 初始化\n在 Quarto 项目文件夹主目录下，使用 git init 进行 Git 初始化。\n新建 .gitignore 文件，在文件中写入 *.csv 和 *.xlsx，忽略数据源文件；再写入 _site/ 忽略本地调试时生成的文件。\n3、在 Github 新建项目库，并关联本地库和远程库\n使用下列命令关联本地库和远程库\n```{git}\ngit remote add origin git@github.com:whuhzx/QuartoBlog.git\ngit branch -M main\ngit push -u origin main\n```\n如果执行过程中返回 fatal: remote origin already exists. 的报错，则重新设置： git remote set-url origin git@github.com:whuhzx/QuartoBlog.git"
  },
  {
    "objectID": "posts/在 Github 上部署 Quarto 的静态网页/index.html#确保-github-和本机电脑已关联",
    "href": "posts/在 Github 上部署 Quarto 的静态网页/index.html#确保-github-和本机电脑已关联",
    "title": "在 Github 上部署 Quarto 的静态网页",
    "section": "确保 Github 和本机电脑已关联",
    "text": "确保 Github 和本机电脑已关联\n如果从未在电脑上使用过 Github，需首先将 Github 账号和本机电脑关联，具体方法是用终端创建 SSH 文件，并将公钥上传到 Github 配置页。具体步骤如下：\n\n确认本机是否已创建 SSH Key\n使用 ls -a ~ 在终端查看本机主目录页是否有 .ssh 目录。若没有，则使用 ssh-keygen -t rsa -C 'myemail@github.com' 创建 ssh 目录，并生成私钥文件 id_rsa 和 公钥文件 id_rsa.pub。\n之后使用 cat /.ssh/id_rsa.pub 查看公钥并复制。\n\n\n将公钥上传到 Github 配置页\n打开 Github，进入 Settings - SSH and GPG keys 页面（或者直接输入 https://github.com/settings/keys网址），点击 New SSH key，将之前复制的公钥粘贴进去。"
  },
  {
    "objectID": "posts/在 Github 上部署 Quarto 的静态网页/index.html#在本地配置-quarto-项目文件夹",
    "href": "posts/在 Github 上部署 Quarto 的静态网页/index.html#在本地配置-quarto-项目文件夹",
    "title": "在 Github 上部署 Quarto 的静态网页",
    "section": "在本地配置 Quarto 项目文件夹",
    "text": "在本地配置 Quarto 项目文件夹\n\n配置 Quarto 项目文件夹\n在 _quarto.yml 文件中写入 output-dir: docs，渲染后会生成 docs 目录，里面就是将要部署的静态网页。\n```{yaml}\nproject:\n  type: website\n  output-dir: docs\n```\n在主目录下使用 touch .nojekyll 新建 .nojekyll 的空文件，告诉 Github 在部署网页时，不要用默认的 Jekyll 处理和渲染网页。\n\n\nQuarto 的 Git 初始化\n在 Quarto 项目主目录下，使用 git init 进行 Git 初始化。\n新建 .gitignore 文件，在文件中写入 *.csv 和 *.xlsx，表示忽略数据源文件；再写入 _site/ 忽略本地调试时生成的文件。"
  },
  {
    "objectID": "posts/在 Github 上部署 Quarto 的静态网页/index.html#在-github-新建项目并关联本地库和远程库",
    "href": "posts/在 Github 上部署 Quarto 的静态网页/index.html#在-github-新建项目并关联本地库和远程库",
    "title": "在 Github 上部署 Quarto 的静态网页",
    "section": "在 Github 新建项目，并关联本地库和远程库",
    "text": "在 Github 新建项目，并关联本地库和远程库\n\n在 Github 新建项目\n在 Github 上新建名为 QuartoBlog 的项目，得到项目的 git 地址 git@github.com:whuhzx/QuartoBlog.git\n\n\n关联本地库和远程库\n使用下列命令关联本地库和远程库，并将本地博客内容推送到 Github 上：\n```{git}\ngit remote add origin git@github.com:whuhzx/QuartoBlog.git\ngit branch -M main\ngit push -u origin main\n```\n如果执行过程中返回 fatal: remote origin already exists. 的报错，则重新设置： git remote set-url origin git@github.com:whuhzx/QuartoBlog.git\n\n\n在 Github 上配置 docs 文件夹\n本地库和远程库关联成功后，在 Github 该项目的设置（Setting）页面，点击左侧 Page 按钮，将 Branch 下的文件夹改成 /docs，表示只渲染该文件夹下的文件。\n\n到这里，已可以在 https://whuhzx.github.io/QuartoBlog 页面上看到内容，静态网站已部署成功。"
  },
  {
    "objectID": "posts/在 Github 上部署 Quarto 的静态网页/index.html#相关资源",
    "href": "posts/在 Github 上部署 Quarto 的静态网页/index.html#相关资源",
    "title": "在 Github 上部署 Quarto 的静态网页",
    "section": "相关资源",
    "text": "相关资源\n\nYoutube: Publishing a Quarto website through GitHub Pages\nQuarto: GitHub Pages"
  },
  {
    "objectID": "posts/在 Github 上部署 Quarto 的静态网页/index.html#更新博客内容",
    "href": "posts/在 Github 上部署 Quarto 的静态网页/index.html#更新博客内容",
    "title": "在 Github 上部署 Quarto 的静态网页",
    "section": "更新博客内容",
    "text": "更新博客内容\n后续更新博客内容时，可使用下列 Git 常用命令：\n1、使用 git add 文件名/目录名 将工作区修改内容添加到缓存区\n2、使用 git status 查看工作区或缓存区状况\n3、使用 git commit -m \"文字说明\" 将缓存区的内容做成一个新的版本，可以在每次写完一篇新的博文内容后做一个新版本\n4、使用 git push -u origin main 将新版本推送到 Github 上"
  },
  {
    "objectID": "posts/使用 gghighlight 制图/index.html",
    "href": "posts/使用 gghighlight 制图/index.html",
    "title": "使用 gghighlight 制图",
    "section": "",
    "text": "library(tidyverse)\nlibrary(gghighlight)\nlibrary(hrbrthemes)"
  },
  {
    "objectID": "posts/使用 gghighlight 制图/index.html#数据准备和清洗",
    "href": "posts/使用 gghighlight 制图/index.html#数据准备和清洗",
    "title": "使用 gghighlight 制图",
    "section": "数据准备和清洗",
    "text": "数据准备和清洗\n先导入数据。\n\njisu_apps <- readxl::read_xlsx(\"QM数据.xlsx\", sheet = 3) \n\njisu_apps数据集中是不同极速版App的月活变化数据。\n\nknitr::kable(head(jisu_apps))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n时间\n快手极速版\n抖音极速版\n爱奇艺极速版\n喜马拉雅极速版\n好看视频极速版\n火山极速版\n美团极速版\nQQ极速版\n腾讯视频极速版\n\n\n\n\n2020-01-01\n10703.60\n9024.61\nNA\n89.47\nNA\n3387.60\nNA\n274.50\n537.34\n\n\n2020-02-01\n11374.78\n7565.89\nNA\n171.90\nNA\n2274.78\nNA\n351.04\n584.78\n\n\n2020-03-01\n11018.65\n6699.28\nNA\n165.85\nNA\n1487.27\nNA\n322.12\n425.26\n\n\n2020-04-01\n11237.10\n7222.69\nNA\n108.06\nNA\n1273.40\nNA\n287.80\n327.93\n\n\n2020-05-01\n11655.08\n7979.54\nNA\n92.20\nNA\n1350.78\nNA\n236.04\n290.39\n\n\n2020-06-01\n12118.11\n8839.93\nNA\n101.82\nNA\n2139.89\nNA\n219.02\n254.15\n\n\n\n\n\n绘图需使用长数据，我们先将宽数据转换为长数据。\n\njisu_apps_long <- jisu_apps %>%\n  pivot_longer(cols = 2:10, names_to = \"应用\", values_to = \"月活\")\n\n\nknitr::kable(head(jisu_apps_long))\n\n\n\n\n时间\n应用\n月活\n\n\n\n\n2020-01-01\n快手极速版\n10703.60\n\n\n2020-01-01\n抖音极速版\n9024.61\n\n\n2020-01-01\n爱奇艺极速版\nNA\n\n\n2020-01-01\n喜马拉雅极速版\n89.47\n\n\n2020-01-01\n好看视频极速版\nNA\n\n\n2020-01-01\n火山极速版\n3387.60"
  },
  {
    "objectID": "posts/使用 gghighlight 制图/index.html#使用-gghighlight-制图",
    "href": "posts/使用 gghighlight 制图/index.html#使用-gghighlight-制图",
    "title": "使用 gghighlight 制图",
    "section": "使用 gghighlight 制图",
    "text": "使用 gghighlight 制图\n其实整个pacakge里主要使用的就是gghighlight()函数。\n先看没有高亮任一线条的样子。\n\njisu_apps_long %>%\n  ggplot(aes(x = 时间, y = 月活)) +\n  geom_line(aes(group = 应用, color = 应用)) +\n  theme_ipsum(base_family = \"PingFang SC\")\n\n\n\n\n再来高亮指定名称的线条。其中label_params主要用来调整高亮线条的名称样式，参数和geom_label_repel一致。\n\njisu_apps_long %>%\n  ggplot(aes(x = 时间, y = 月活)) +\n  geom_line(aes(group = 应用, color = 应用)) +\n  gghighlight(应用 == '快手极速版', label_params = list(family = \"PingFang SC\")) +\n  theme_ipsum(base_family = \"PingFang SC\")\n\n\n\n\n线条名称可以改用图例的形式，而不直接在线条结尾处展现标签。这里需使用use_direct_label参数。\n\njisu_apps_long %>%\n  ggplot(aes(x = 时间, y = 月活)) +\n  geom_line(aes(group = 应用, color = 应用)) +\n  gghighlight(应用 == '快手极速版', use_direct_label = FALSE) +\n  theme_ipsum(base_family = \"PingFang SC\")\n\n\n\n\n还可以使用函数筛选需要高亮的线条。例如通过max(月活) > 10000筛选出月活过亿的应用。\n\njisu_apps_long %>%\n  ggplot(aes(x = 时间, y = 月活)) +\n  geom_line(aes(group = 应用, color = 应用)) +\n  gghighlight(max(月活) > 10000, use_direct_label = FALSE) +\n  theme_ipsum(base_family = \"PingFang SC\")\n\n\n\n\n结合max_highlight参数，指定高亮的最大线条数。\n\njisu_apps_long %>%\n  ggplot(aes(x = 时间, y = 月活)) +\n  geom_line(aes(group = 应用, color = 应用)) +\n  gghighlight(max(月活, na.rm = TRUE), max_highlight = 3, use_direct_label = FALSE) +\n  theme_ipsum(base_family = \"PingFang SC\")\n\n\n\n\n如果有更细粒度的需求，例如2023年月活最高的三个应用，则无法通过gghighlight()内置参数直接实现，需要先计算得到这三个应用的名称。\n\ntop3_app_names <- jisu_apps_long %>%\n  filter(lubridate::year(时间) == 2023) %>%\n  group_by(应用) %>%\n  top_n(1, 月活) %>%\n  ungroup() %>%\n  arrange(desc(月活)) %>%\n  top_n(3, 月活) %>%\n  pull(应用)\n\n# 也可使用行计算，结果和上面一样\n# top3_app_names2 <- jisu_apps_long %>%\n#   filter(lubridate::year(时间) == 2023) %>%\n#   pivot_wider(names_from = 时间, values_from = 月活) %>%\n#   rowwise() %>%\n#   mutate(最大月活 = max(across(where(is.numeric)))) %>%\n#   ungroup() %>%\n#   top_n(3, 最大月活) %>%\n#   pull(应用)\n  \njisu_apps_long %>%\n  ggplot(aes(x = 时间, y = 月活)) +\n  geom_line(aes(group = 应用, color = 应用)) +\n  gghighlight(应用 %in% top3_app_names, use_direct_label = FALSE) +\n  theme_ipsum(base_family = \"PingFang SC\")\n\n\n\n\n最后按应用进行分面。\n\njisu_apps_long %>%\n  mutate(应用 = fct_reorder(应用, -月活, mean, na.rm = TRUE)) %>%\n  ggplot(aes(x = 时间, y = 月活)) +\n  geom_line(aes(group = 应用, color = 应用), size = 0.7) +\n  # 为了看清趋势采用对数坐标轴\n  scale_y_log10() +\n  theme_ipsum(base_family = \"PingFang SC\", grid = \"XY\") +\n  gghighlight(use_direct_label = FALSE) +\n  facet_wrap(~应用) +\n  guides(color = FALSE) +\n  labs(y = \"月活（万人）\")"
  },
  {
    "objectID": "posts/使用 gghighlight 制图/index.html#参考资料",
    "href": "posts/使用 gghighlight 制图/index.html#参考资料",
    "title": "使用 gghighlight 制图",
    "section": "参考资料",
    "text": "参考资料\n\nIntroduction to gghighlight\nLine chart with small multiple"
  },
  {
    "objectID": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html",
    "href": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html",
    "title": "使用 geom_ribbon 给双折线区间填充颜色",
    "section": "",
    "text": "平常看数据图表时，经常见到这么一种图表类型——一张图里有两条折线 A 和 B，当 A 大于 B 时，AB 空间里填充一种颜色；当 B 大于 A 时，AB 空间里填充另一种颜色。\n例如《华盛顿邮报》制作的这张图：\n\n探索了一下，发现可以借助 geom_ribbon 函数实现类似功能。"
  },
  {
    "objectID": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html#包引入",
    "href": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html#包引入",
    "title": "使用 geom_ribbon 给双折线区间填充颜色",
    "section": "包引入",
    "text": "包引入\n\nlibrary(tidyverse)\nlibrary(hrbrthemes)\nlibrary(patchwork)"
  },
  {
    "objectID": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html#数据准备和清洗",
    "href": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html#数据准备和清洗",
    "title": "使用 geom_ribbon 给双折线区间填充颜色",
    "section": "数据准备和清洗",
    "text": "数据准备和清洗\n先导入数据。\n\napps_mau <- readxl::read_xlsx(\"QM数据.xlsx\", sheet = 1)\n\napps_mau 数据集里面有快手、百度等移动应用的财报月活数据和 QM 监测到的月活数据。\n\nknitr::kable(head(apps_mau))\n\n\n\n\n时间\n财报数据\nQM数据\n应用名\n\n\n\n\n2020Q1\n4.95\n5.15\n快手（主站+极速版）\n\n\n2020Q2\n4.74\n4.97\n快手（主站+极速版）\n\n\n2020Q3\n4.79\n5.05\n快手（主站+极速版）\n\n\n2020Q4\n4.76\n5.22\n快手（主站+极速版）\n\n\n2021Q1\n5.20\n5.71\n快手（主站+极速版）\n\n\n2021Q2\n5.06\n5.26\n快手（主站+极速版）\n\n\n\n\n\n现在要做的是：当 QM 监测数据高于该应用的财报数据时，采用一种颜色填充；当 QM 监测数据低于财报数据时，采用另外一种颜色填充。\n对数据进行简单地清洗。\n\napps_mau_clean <- apps_mau %>%\n  # 把数据类型从字符串转换成时间，geom_ribbon 的参数需要是数值型变量\n  mutate(时间 = zoo::as.yearqtr(时间)) %>%\n  # 因子排序，后续做分面图时按照月活差距排序\n  mutate(应用名 = fct_reorder(应用名, 财报数据 - QM数据, mean))\n\n\nknitr::kable(head(apps_mau_clean))\n\n\n\n\n时间\n财报数据\nQM数据\n应用名\n\n\n\n\n2020 Q1\n4.95\n5.15\n快手（主站+极速版）\n\n\n2020 Q2\n4.74\n4.97\n快手（主站+极速版）\n\n\n2020 Q3\n4.79\n5.05\n快手（主站+极速版）\n\n\n2020 Q4\n4.76\n5.22\n快手（主站+极速版）\n\n\n2021 Q1\n5.20\n5.71\n快手（主站+极速版）\n\n\n2021 Q2\n5.06\n5.26\n快手（主站+极速版）\n\n\n\n\n\n后续作图时， 由于 geom_ribbon 使用宽数据，geom_line 使用长数据，因此此处需做一个数据类型的转换。\n\napps_mau_longdata <- apps_mau_clean %>%\n  # 看QM数据相较于财报数据偏离比例有多少\n  mutate(diff = (QM数据 - 财报数据) / 财报数据,\n         diff_format = str_c(round(diff,2) * 100, \"%\")) %>%\n  pivot_longer(cols = c('财报数据', 'QM数据'),\n               names_to = '数据来源',\n               values_to = '月活') \n\n再来看看转换后的数据。\n\nknitr::kable(head(apps_mau_longdata))\n\n\n\n\n时间\n应用名\ndiff\ndiff_format\n数据来源\n月活\n\n\n\n\n2020 Q1\n快手（主站+极速版）\n0.0404040\n4%\n财报数据\n4.95\n\n\n2020 Q1\n快手（主站+极速版）\n0.0404040\n4%\nQM数据\n5.15\n\n\n2020 Q2\n快手（主站+极速版）\n0.0485232\n5%\n财报数据\n4.74\n\n\n2020 Q2\n快手（主站+极速版）\n0.0485232\n5%\nQM数据\n4.97\n\n\n2020 Q3\n快手（主站+极速版）\n0.0542797\n5%\n财报数据\n4.79\n\n\n2020 Q3\n快手（主站+极速版）\n0.0542797\n5%\nQM数据\n5.05"
  },
  {
    "objectID": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html#绘图",
    "href": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html#绘图",
    "title": "使用 geom_ribbon 给双折线区间填充颜色",
    "section": "绘图",
    "text": "绘图\n绘图时会用到三个 geom 图形函数：geom_line 用来绘制折线，geom_text 用来绘制QM数据相较于财报数据的偏离值，而geom_ribbon 用于给折线差值空间填充颜色。\n其中 geom_ribbon 的主要 aes() 参数是 x、y、xmin、ymin、xmax、ymax，表示绘图空间的起始及结束坐标。另外，fill 表示填充的颜色，alpha 表示透明度。\n\napps_plot <- apps_mau_longdata %>%\n  # x = 时间的数据类型需是泛 date 类型,否则无效\n  ggplot(aes(x = 时间)) +\n  # 分组折线图\n  geom_line(aes(y = 月活, group = 数据来源, color = 数据来源)) +\n  # 标注出偏离比例\n  geom_text(data = apps_mau_longdata %>% filter(数据来源 == 'QM数据'),\n            aes(y = 月活, label = diff_format)) +\n  # 折线差值部分填充颜色\n  geom_ribbon(\n    data = apps_mau_clean %>% mutate(颜色 = ifelse(财报数据>QM数据, '财报数据', 'QM数据')),\n    mapping = aes(\n      # pmin 和 pmax 函数表示在一组向量中分别取最小和最大值\n      ymin = pmin(财报数据, QM数据),\n      ymax = pmax(财报数据, QM数据),\n      fill = 颜色),\n    alpha = 0.3\n  ) +\n  facet_wrap(~ 应用名, ncol = 2) +\n  scale_x_continuous(\n    # 横轴标签只出现7个\n    breaks = scales::pretty_breaks(n = 7),\n    # 横纵标签默认为'2020-01 的格式，将其格式化为 2020Q1'\n    labels = function(x) format(zoo::as.yearqtr(x), \"%YQ%q\")) +\n  guides(fill = 'none') +\n  theme_ipsum(base_family = 'PingFang SC', grid = 'XY')\n\n\n需要注意的是，使用 goem_ribbon 有一个缺点：当两条折线交叉的时候，交叉点附近区域无法被正确填色（仔细看的话会发现，快手分面图中两线交汇的地方是空白的）。\n这是由于geom_ribbon的工作原理所导致的：geom_ribbon 会以 y 轴的值作为区域的边界，所以当两条线交叉时，那一点的 y 值是不确定的，所以 ggplot2 不会在那个位置上色。\n针对这点，暂时没有发现特别好的解决方法。只能等生成 svg 图形后，在 Figma 里手动调整。"
  },
  {
    "objectID": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html#注意事项",
    "href": "posts/使用 geom_ribbon 为折线差值填充颜色/index.html#注意事项",
    "title": "使用 geom_ribbon 给双折线区间填充颜色",
    "section": "注意事项",
    "text": "注意事项\n1、数据结构方面。goem_line 使用的是长数据，而 goem_ribbon 使用的是宽数据。将它们同时绘制在一张图里的时候，需要做数据转换，不能使用同一个数据集。\n2、数据类型方面。使用 geom_ribbon 绘图时，x轴和y轴都必须是数值型变量或者时间变量，数据类型不对的话虽不会报错，但也无法绘制出任何结果。这里 debug 了好久才发现问题，最后使用 zoo pacakge 的 as.yearqtr 函数将时间（2020Q1）由字符串格式转换成时间格式。"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "",
    "text": "很久之前就想创建一个 R 包，便于在做数据分析的时候根据个人需求复用函数，但因为觉得相关文档太复杂而放弃了。\n这次试了试用ChatGPT来帮助编写，发现过程还是比较简单的。虽然也花时间扫了一遍 Hadley Wickham 编写的《R Package》，但是有 ChatGPT 的帮助，能够对书中的内容和底层的机制有更清楚地了解。\n这里简单记录一下过程。为了方便起见，编写的R包里只有一个函数。"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#准备",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#准备",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "准备",
    "text": "准备\n事先需要安装两个服务于R包开发的 package，分别是 devtools 和 roxygen2，后者主要用于自动生成包的帮助文档。\n\nlibrary(devtools)\nlibrary(roxygen2)\n\n在 RStudio 中新建项目，并选择 R Package，就会自动生成一个工程文件夹。文件目录大致如下：\n\nmyutils/\n|-- DESCRIPTION #描述文件，内容包括基本信息，如包的名称、版本、作者、描述、依赖等\n|-- NAMESPACE #文件指定了哪些函数或对象应该被导出（用户可以直接访问）以及哪些其他的包的函数应该被导入 \n|-- R/ #在目录中放置所有的R函数代码\n|   |-- function1.R\n|   |-- function2.R\n|-- man/ #在目录中放置函数的帮助文档。这些文件通常使用roxygen2注释在R文件中自动生成。\n|   |-- function1.Rd\n|   |-- function2.Rd\n|-- data/ #目录用于存放包中的数据集\n|   |-- dataset1.RData\n|-- inst/ #存放不适合其他类别的文件。\n|   |-- extdata/\n|   |   |-- some_additional_data.csv\n|-- tests/ #放置测试代码，通常使用testthat包来编写测试，此次不涉及\n|   |-- testthat/\n|   |   |-- test_function1.R\n|   |   |-- test_function2.R\n|-- vignettes/ #存放包的使用教程或详细文档\n|   |-- introduction.Rmd\n|-- LICENSE"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#填写description文件",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#填写description文件",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "填写DESCRIPTION文件",
    "text": "填写DESCRIPTION文件\n在DESCRIPTION文件中填入包的基本信息。\n如果R包需要引入外部package，需要在文件中加入Imports依赖，这里我们编写的函数需要引入tidyverse和tidytext两个包。\n\nPackage: myutils\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true # 包中如果含有数据集，true表示library()不加载数据集，使用到数据集时才加载\nImports: \n    tidyverse,\n    tidytext"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#添加函数",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#添加函数",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "添加函数",
    "text": "添加函数\n这里添加一个我常使用的计算TGI的函数 compute_tgi_top_n。\n#' 后面填上函数的介绍，#' @param 后面则是每个参数的含义，后续 roxygen2 会根据注释在R文件中自动生成帮助文件。\n#' @export 表示这个函数可以被外部调用，如果不加入这个注释，表明只供内部使用，外部使用者在 library(myutils) 加载包后无法使用该函数。\n\n#' Compute dataset TGI\n#' @param x 数据集\n#' @param target 目标对象\n#' @param category 分组类型\n#' @param tgi_value 数值\n#' @param top_number 最大排名\n#' @export\ncompute_tgi_top_n <- function(x, target, category, tgi_value, top_number = 10){\n  x %>%\n    group_by(!!sym(target), !!sym(category)) %>%\n    summarise(value = sum(!!sym(tgi_value))) %>%\n    ungroup() %>%\n    mutate(total = sum(value)) %>%\n    group_by(!!sym(target)) %>%\n    mutate(target_ratio = value / sum(value)) %>%\n    ungroup() %>%\n    group_by(!!sym(category)) %>%\n    mutate(total_ratio = sum(value) / total) %>%\n    mutate(tgi = round(target_ratio / total_ratio * 100, 0)) %>%\n    ungroup() %>%\n    arrange(desc(tgi)) %>%\n    group_by(!!sym(target)) %>%\n    top_n(top_number, tgi) %>%\n    ggplot(aes(x = tgi, y = reorder_within(!!sym(category), tgi, !!sym(target)))) +\n    geom_col() +\n    geom_text(aes(label = tgi)) +\n    facet_wrap(vars(!!sym(target)), scale = \"free\") +\n    scale_y_reordered() +\n    theme(text = element_text(family = \"PingFang SC\"))\n}"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#添加数据集",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#添加数据集",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "添加数据集",
    "text": "添加数据集\n如果要在开发的包中加入固定数据集以供后续载入调用，可以将数据集放置在 /data 目录下。\n根据《R Pacakge》一书，数据集的最佳保存格式为 .rda。可以使用 save(my_data, file = \"my_data.rda\") 将数据集保存为该格式，或者使用 usethis::use_data(my_data) 自动保存。"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#生成文档",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#生成文档",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "生成文档",
    "text": "生成文档\n执行 roxygenise() 后，会在 /man 目录下生成一个名为compute_tgi_top_n.Rmd 的文件，里面是该函数的帮助文档。\n\nsetwd(\"path_to_myutils\")  # 将包的项目路径设置为工作目录\nroxygen2::roxygenise()\n\n执行 roxygenise() 后发生了什么？以下是 ChatGPT 给出的回答。\n\n- 解析roxygen注释：函数会检查你的R源代码文件，寻找以#'开始的roxygen注释。\n\n- 生成.Rd文件：对于源代码中的每个函数、类或数据集，roxygenise()会在man/目录中生成一个.Rd文件。这些文件为R包中的每个公共对象提供手册页。\n\n- 更新NAMESPACE文件：基于roxygen注释中的@export、@import、@importFrom等标签，NAMESPACE文件会被自动更新。例如，如果你在函数上方有#' @export注释，该函数将被导出，允许用户在加载包后直接访问它。\n\n- 生成vignettes：如果你在包中包含了vignettes（即长格式的文档或教程），并且使用roxygen2标签为它们编写了元数据，那么roxygenise()也会处理这些vignettes。\n\n- 其他文档更新：roxygen2也支持许多其他标签，这些标签可以帮助生成数据集的文档、包的描述和其他文档部分。"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#将包安装到本地库中",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#将包安装到本地库中",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "将包安装到本地库中",
    "text": "将包安装到本地库中\n使用 devtools 包内置的 install() 函数，就能够将包安装到本地库中，方便后续直接用 library() 调用。\n\ndevtools::install(\"myutils\")\n\n执行 install() 后发生了什么？ChatGPT 给出了如下答案，有助于理解包安装背后的机制。\n\n- 构建：首先，R会将你的包的所有文件打包成一个.tar.gz文件（在Linux和Mac上）或.zip文件（在Windows上）。这个文件是R包的源代码格式。\n\n- 检查包的依赖关系：install()会查看myutils包的DESCRIPTION文件，找到任何在Depends、Imports或LinkingTo字段中列出的依赖关系。如果这些依赖的包还没有被安装，install()通常会尝试自动安装它们。\n\n- 编译：如果你的包包含任何C、C++或Fortran代码，R会尝试编译这些代码。这需要有合适的编译工具链。例如，在Windows上，你可能需要Rtools来编译C或C++代码。\n\n- 安装：一旦包被构建并编译（如果需要的话），它就会被安装到R的库中。这实际上就是将包的所有文件复制到R的包目录，通常是library/目录。\n\n- 加载：安装后，你可以使用library(myutils)命令加载并使用你的包。\n\n- 二进制包：在某些系统上，例如Windows，install()可能还会为你的包创建一个二进制版本，这样在未来安装包时可以更快。\n\n接下来就可以在本地加载 library(myutils) 后调用 compute_tgi_top_n() 函数了。也可以通过 ?compute_tgi_top_n 来查看帮助文档。"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#将包上传到github上",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#将包上传到github上",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "将包上传到Github上",
    "text": "将包上传到Github上\n最后，我们进入包目录，将本地包初始化并新做一个版本。\n\ngit init\ngit add .\ngit commit -m \"first package version\"\n\n在个人 Github 主页上新建一个库。然后，将本地库和远程库建立关联。\n\ngit remote add origin git@github.com:your_username/myutils.git\n\n# 若显示远程库已存在，则加上 set-url 更新一下\ngit remote set-url origin git@github.com:your_username/myutils.git\n\n将本地库推送到Github上。\n\n# 重命名当前活动分支为 main\ngit branch -M main\n\n# 将main分支推送到名为 origin 的远程仓库，并设置上游追踪关系\ngit push -u origin main\n\n推送完成，之后可以在任何电脑上使用 install_github() 命令来安装这个R包啦。\n\ndevtools::install_github(\"your_username/myutils\")"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#相关资源",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#相关资源",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "相关资源",
    "text": "相关资源\n\n《R Packages》\n为新手准备的现代化 R 包开发流程"
  },
  {
    "objectID": "posts/常用包和函数汇总/index.html#其他资源",
    "href": "posts/常用包和函数汇总/index.html#其他资源",
    "title": "R 常用包和函数汇总",
    "section": "其他资源",
    "text": "其他资源\n\nR 包开发可见利用 ChatGPT 编写简单 R 包。"
  },
  {
    "objectID": "posts/Quarto 常用语法汇总/index.html",
    "href": "posts/Quarto 常用语法汇总/index.html",
    "title": "Quarto 常用语法汇总",
    "section": "",
    "text": "年纪大了记忆力不好，记录一下常用语法，避免每次都要重新翻阅和查询 Quarto 的文档。"
  },
  {
    "objectID": "posts/Quarto 常用语法汇总/index.html#博文配置",
    "href": "posts/Quarto 常用语法汇总/index.html#博文配置",
    "title": "Quarto 常用语法汇总",
    "section": "博文配置",
    "text": "博文配置\n每篇博文开头需要配置的参数。\n\n---\ntitle: \"Quarto 常用语法汇总\"\nauthor: \"Boyce\"\ndate: \"2023/08/12\"\ncategories: [Quarto, 清单]\n---\n\nQuarto会根据.qmd文件的内容自动选择引擎来渲染文件。也可以在开头通过全局命令指定。\n\n---\ntitle: \"Quarto 常用语法汇总\"\nauthor: \"Boyce\"\nengine: knitr\n---\n\n如果需要代码块执行某些操作或者不执行某些操作，可以在开头使用execute进行全局设置。例如，eval: false表示只展示代码而不执行代码，也不会返回任何结果。\n\nexecute: \n  eval: false\n\n如果在单个代码块的开头修改execute，可以覆盖开头的全局配置。例如在代码第一行写入#| eval: true，表示在该代码块上执行代码。\n其他常用配置还包括：\n\nwarning: false表示执行代码但不返回警告。\necho: false 表示只展示输出结果，但不展示源代码。\nerror: true 表示在执行过程遇到报错也不会停止文档处理。\n\n关于execute的配置，详见文档。"
  },
  {
    "objectID": "posts/Quarto 常用语法汇总/index.html#代码块",
    "href": "posts/Quarto 常用语法汇总/index.html#代码块",
    "title": "Quarto 常用语法汇总",
    "section": "代码块",
    "text": "代码块\n如果只需要展示代码块的样式，而不需要在其中高亮任何元素，可以直接使用 {default}。\n如果觉得单行代码太长，想要在代码块中直接换行，可以在开头写入 #| code-overflow: wrap。"
  },
  {
    "objectID": "posts/Quarto 常用语法汇总/index.html#表格",
    "href": "posts/Quarto 常用语法汇总/index.html#表格",
    "title": "Quarto 常用语法汇总",
    "section": "表格",
    "text": "表格\n想在文章中展示表格样式，可以使用 knitr::kable(dataset)。"
  },
  {
    "objectID": "posts/Quarto 常用语法汇总/index.html#相关资源",
    "href": "posts/Quarto 常用语法汇总/index.html#相关资源",
    "title": "Quarto 常用语法汇总",
    "section": "相关资源",
    "text": "相关资源\n\nQuarto文档\nAwesome Quarto"
  },
  {
    "objectID": "posts/Quarto 常用语法汇总/index.html#单篇博文配置",
    "href": "posts/Quarto 常用语法汇总/index.html#单篇博文配置",
    "title": "Quarto 常用语法汇总",
    "section": "单篇博文配置",
    "text": "单篇博文配置\n每篇博文开头需要配置的参数。\n\n---\ntitle: \"Quarto 常用语法汇总\"\nauthor: \"Boyce\"\ndate: \"2023/08/12\"\ncategories: [Quarto, 清单]\n---\n\nQuarto 支持使用 Knitr 和 Jupyter 两类引擎，它会根据当面的 .qmd 文件内容自动选择引擎来渲染网页文件，我们也可以在开头通过全局命令指定，例如：\n\n---\nengine: knitr\n---\n\n如果需要代码块执行某些操作或者不执行某些操作，同样可以在开头使用 execute 进行全局设置。例如，eval: false 表示只展示代码而不执行代码，也不会返回任何结果。\n\n---\nexecute: \n  eval: false\n---\n\n如果在单个代码块的开头修改 execute，可以覆盖开头的全局配置。例如在代码第一行写入 #| eval: true，表示在该代码块上执行代码。\n其他常用配置还包括：\n\nwarning: false 表示执行代码但不返回警告。\necho: false 表示只展示输出结果，但不展示源代码。\nerror: true 表示在执行过程遇到报错也不会停止文档处理。\n\n关于 execute 的配置，详见文档。"
  },
  {
    "objectID": "posts/利用 ChatGPT 编写简单 R 包/index.html#填写-description-文件",
    "href": "posts/利用 ChatGPT 编写简单 R 包/index.html#填写-description-文件",
    "title": "利用 ChatGPT 编写简单 R 包",
    "section": "填写 DESCRIPTION 文件",
    "text": "填写 DESCRIPTION 文件\n在 DESCRIPTION 文件中填入包的基本信息。\n如果R包需要引入外部 package，需要在文件中加入 Imports 依赖，这里我们编写的函数需要引入 tidyverse 和 tidytext 两个包。\n\nPackage: myutils\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true # 包中如果含有数据集，true 表示 library() 不加载数据集，使用到数据集时才加载\nImports: \n    tidyverse,\n    tidytext"
  },
  {
    "objectID": "posts/文本可视化的一种方式：词语在两个数据集中的排名对比/index.html",
    "href": "posts/文本可视化的一种方式：词语在两个数据集中的排名对比/index.html",
    "title": "文本可视化的一种方式：词语在两个数据集中的排名对比",
    "section": "",
    "text": "文本是社交媒体上最易获得的数据，但可视化形式却相对单一，基本上是词云一招鲜。\n这背后其实更多是分析思路的问题，即不考虑其他维度（时间、关系、分类等），把所有文本一视同仁，简单粗暴地进行分词后做成词云。\n而引入对比的视角，不仅可以打开分析思路，还能让文本数据的表现形式更加丰富。\n举个例子，当我们想分析短视频平台上”村BA”比赛评论的特色时，可以引入对比，即比较”村BA”和 NBA 评论的区别，进而提炼出”村BA”运动的特色，这会比单独分析”村BA”会更加有趣。"
  },
  {
    "objectID": "posts/文本可视化的一种方式：词语在两个数据集中的排名对比/index.html#包引入",
    "href": "posts/文本可视化的一种方式：词语在两个数据集中的排名对比/index.html#包引入",
    "title": "文本可视化的一种方式：词语在两个数据集中的排名对比",
    "section": "包引入",
    "text": "包引入\n\nlibrary(tidyverse)\nlibrary(hrbrthemes)\nlibrary(gghighlight)\nlibrary(readxl)"
  },
  {
    "objectID": "posts/文本可视化的一种方式：词语在两个数据集中的排名对比/index.html#数据引入和清洗",
    "href": "posts/文本可视化的一种方式：词语在两个数据集中的排名对比/index.html#数据引入和清洗",
    "title": "文本可视化的一种方式：词语在两个数据集中的排名对比",
    "section": "数据引入和清洗",
    "text": "数据引入和清洗\n先从 NBA 和”村BA”相关短视频中各随机选取 50 万条评论，分词后筛选出词频最高的 1000 个词。\n\ncomments_word_top1000 <- read_xlsx(\"comments_word_top1000.xlsx\")\n\nknitr::kable(head(comments_word_top1000))\n\n\n\n\nsegword\nNBA\n村BA\ntotal\n\n\n\n\n赞\n175390\n222006\n397396\n\n\n玫瑰\n159561\n30730\n190291\n\n\n666\n68798\n29446\n98244\n\n\nNA\n60378\n22901\n83279\n\n\n爱心\n64769\n18192\n82961\n\n\n捂脸\n29914\n51536\n81450\n\n\n\n\n\n但这里不能直接使用词频进行对比，因为 NBA 和”村BA”两个数据集的词语数量不同，无法直接比较。因此我们改为使用排名，即单个词语在各自数据集中的排名。\n\nclean_comments_word <- comments_word_top1000 %>%\n  mutate(NBA = rank(-NBA, ties.method = \"min\"),\n         村BA = rank(-村BA, ties.method = \"min\")) %>%\n  select(-total)\n\n\nknitr::kable(head(clean_comments_word))\n\n\n\n\nsegword\nNBA\n村BA\n\n\n\n\n赞\n1\n1\n\n\n玫瑰\n2\n4\n\n\n666\n3\n5\n\n\nNA\n5\n8\n\n\n爱心\n4\n11\n\n\n捂脸\n7\n2\n\n\n\n\n\n这里使用了 rank 函数返回排名。其中 ties.method 参数表示当两个数值大小一致时采取的计算方法，默认返回均值。\n\nknitr::kable(\n  tibble(\n  origin = rank(c(1,2,3,3,4)),\n  min = rank(c(1,2,3,3,4), ties.method = \"min\"),\n  max = rank(c(1,2,3,3,4), ties.method = \"max\"))\n)\n\n\n\n\norigin\nmin\nmax\n\n\n\n\n1.0\n1\n1\n\n\n2.0\n2\n2\n\n\n3.5\n3\n4\n\n\n3.5\n3\n4\n\n\n5.0\n5\n5\n\n\n\n\n\n接下来，我们肉眼筛选出能够表达 NBA 和”村BA”各自特色的评论词语，以及能够表达两类比赛共同点的评论词语。\n\nselected_word <- c(\"詹姆斯\", \"库里\", \"欧文\", \"奥尼尔\",\"人民\",\"接地气\",\"纯粹\", \"热爱\", \"气氛\",  \"厉害\",  \"漂亮\", \"加油\", \"支持\")"
  },
  {
    "objectID": "posts/文本可视化的一种方式：词语在两个数据集中的排名对比/index.html#可视化制图",
    "href": "posts/文本可视化的一种方式：词语在两个数据集中的排名对比/index.html#可视化制图",
    "title": "文本可视化的一种方式：词语在两个数据集中的排名对比",
    "section": "可视化制图",
    "text": "可视化制图\n为了对比这些词语在两个数据集中的排位差距，可以采用类折线图的可视化形式。\n\nclean_comments_word %>%\n  filter(segword %in% selected_word) %>%\n  pivot_longer(cols = c(\"NBA\", \"村BA\"), names_to = \"type\", values_to = \"n\") %>%\n  ggplot(aes(x = type, y = n)) +\n  geom_line(aes(group = segword)) +\n  geom_text(aes(label = segword), family = \"PingFang SC\") +\n  labs(x = \"\", y = \"评论词排名\") +\n  scale_y_reverse() + # 翻转纵坐标轴，排名高的放在上面比较合理\n  hrbrthemes::theme_ipsum(base_family = \"PingFang SC\", grid = \"XY\")\n\n\n\n\n如前所述（也可从图中直观看见），我们可以将这些词语大致分为三类。接着，我们根据词语在两个数据集中的排名差距（以300为界）分成三类，再通过分面的可视化形式展示各自的特点。\n\nclean_comments_word %>%\n  filter(segword %in% selected_word) %>%\n  mutate(facet = case_when(\n    NBA - 村BA >= 300 ~ \"村BA\\n纯粹热爱\",\n    NBA - 村BA <= -300 ~ \"NBA\\n召唤英雄\",\n    .default = \"共同点\\n为体育喝彩\"\n  )) %>%\n  pivot_longer(cols = c(\"NBA\", \"村BA\"), names_to = \"type\", values_to = \"n\") %>%\n  ggplot(aes(x = type, y = n)) +\n  geom_line(aes(group = segword)) +\n  gghighlight(use_direct_label = FALSE) +\n  geom_text(aes(label = segword), family = \"PingFang SC\") +\n  labs(x = \"\", y = \"评论词排名\") +\n  scale_y_reverse() + # 翻转纵坐标轴，排名高的放在上面比较合理\n  facet_wrap(~facet) +\n  hrbrthemes::theme_ipsum(base_family = \"PingFang SC\", grid = \"XY\")\n\n\n\n\n到这里，图表雏形已经出来了。但还有两个地方可以改进，一是词语的文本会在左右两轴同时出现，太过冗余，现在想要让词语在哪个数据集中排位高，就出现在哪边；二是起始坐标轴应该为 1 而不是 0。\n\nclean_comments_word %>%\n  filter(segword %in% selected_word) %>%\n  mutate(facet = case_when(\n    NBA - 村BA >= 300 ~ \"村BA\\n纯粹热爱\",\n    NBA - 村BA <= -300 ~ \"NBA\\n召唤英雄\",\n    .default = '共同点\\n为体育喝彩'\n  )) %>%\n  # 设置过滤，返回排名高的数据集名称\n  mutate(text_filter = ifelse(NBA >= 村BA, \"村BA\", \"NBA\")) %>%\n  pivot_longer(cols = c(\"NBA\", \"村BA\"), names_to = \"type\", values_to = \"n\") %>%\n  ggplot(aes(x = type, y = n)) +\n  geom_line(aes(group = segword)) +\n  gghighlight(use_direct_label = FALSE) +\n  # 利用之前设置的过滤条件\n  geom_text(data = . %>% filter(type == text_filter),\n            aes(label = segword), family = \"PingFang SC\") +\n  labs(x = \"\", y = \"评论词排名\") +\n  # 手动设置纵坐标轴\n  scale_y_reverse(breaks = c(1,250, 500, 750, 1000), labels = c(1,250, 500, 750, 1000)) +\n  facet_wrap(~facet) +\n  hrbrthemes::theme_ipsum(base_family = \"PingFang SC\", grid = \"XY\")\n\n\n\n\n到此大功告成，如果有需要，还可在设计软件中进一步调整。"
  },
  {
    "objectID": "posts/作图时如何正确渲染中文字体/index.html",
    "href": "posts/作图时如何正确渲染中文字体/index.html",
    "title": "作图时如何正确渲染中文字体",
    "section": "",
    "text": "在 RStudio 中使用 ggplot 作图时，常常需要指定中文字体，但是 ggplot 无法识别字体的中文名称。\n在 MacOS 下又没有一个简便的方式可以查到阿里普惠体、字制区喜脉体等中文字体对应的英文名。在网上查询也不方便且不可靠，因为字体安装的来源不同，英文名也可能不一样。\n后来发现使用 systemfonts 包可以很方便地解决这个问题。安装包后，使用 system_fonts() 函数 会返回一个表格。表格中有系统下所有已安装的字体名称、字体文件路径、字体家族、字重等等信息，很容易就可以通过筛选功能找到自己所需要的字体名称。\n\nlibrary(systemfonts)\nknitr::kable(head(system_fonts()))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npath\nindex\nname\nfamily\nstyle\nweight\nwidth\nitalic\nmonospace\n\n\n\n\n/System/Library/Fonts/Supplemental/Shree714.ttc\n1\nShreeDev0714-Bold\nShree Devanagari 714\nBold\nbold\nnormal\nFALSE\nFALSE\n\n\n/System/Library/Fonts/Supplemental/Muna.ttc\n0\nMuna\nMuna\nRegular\nnormal\nnormal\nFALSE\nFALSE\n\n\n/System/Library/Fonts/Supplemental/Academy Engraved LET Fonts.ttf\n0\nAcademyEngravedLetPlain\nAcademy Engraved LET\nPlain\nnormal\nnormal\nFALSE\nFALSE\n\n\n/System/Library/Fonts/Supplemental/Impact.ttf\n0\nImpact\nImpact\nRegular\nheavy\nsemicondensed\nFALSE\nFALSE\n\n\n/System/Library/AssetsV2/com_apple_MobileAsset_Font7/ad8c3bb76851adc11dc4772c1a7a00caf83e3037.asset/AssetData/Ornanong.ttc\n1\nPSLOrnanongPro-Italic\nPSL Ornanong Pro\nItalic\nnormal\nnormal\nTRUE\nFALSE\n\n\n/System/Library/AssetsV2/com_apple_MobileAsset_Font7/5a3fc034b64879656271c040cab38b65d4ea6548.asset/AssetData/LiSongPro.ttf\n0\nLiSongPro\nLiSong Pro\nLight\nlight\nnormal\nFALSE\nFALSE\n\n\n\n\n\n经查询，阿里普惠体在本地的英文名为 Alibaba-PuHuiTi-R。\n但在有些情况下，使用 ggplot 时可以正常显示字体，当需要将其保存为 pdf、svg 等文件格式时，会出现无法成功渲染字体的报错。这时候就需要使用 showtext 包来处理，具体使用方法可见文档。\n\nlibrary(showtext)\n\n# 打开开关，打开后默认使用 showtext 渲染字体\nshowtext_auto()\n\n# 加载字体，family参数为自定义的字体名称，路径为本地字体文件 .ttf 的路径\nfont_add(family = \"PuHuiTi\", regular = \"/Library/Fonts/Alibaba-PuHuiTi-Regular.ttf\")\n\n# 使用字体时，直接填入之前自定义的字体 PuHuiTi\ndf %>%\n  ggplot(aes(x = n, y = hetu)) +\n  geom_col() +\n  theme_ipsum(base_family = \"PuHuiTi\") +\n  ggsave(\"plot.svg\")\n\n# 关闭开关\nshowtext_auto(enable = FALSE)\n\n但这样的方法也有很大的问题：特别是在以 svg 格式保存后，这时设计软件中所有的字体都变成了路径，也就没有了字体的属性，即无法再改成别的字体，或者调整字号、字重等。"
  },
  {
    "objectID": "posts/作图时如何正确渲染中文字体/index.html#相关资源",
    "href": "posts/作图时如何正确渲染中文字体/index.html#相关资源",
    "title": "作图时如何正确渲染中文字体",
    "section": "相关资源",
    "text": "相关资源\n\nSystemfonts Github Pages\nshowtext: Using Fonts More Easily in R Graphs"
  },
  {
    "objectID": "posts/常用包和函数汇总/index.html#数据图表",
    "href": "posts/常用包和函数汇总/index.html#数据图表",
    "title": "R 常用包和函数汇总",
    "section": "数据图表",
    "text": "数据图表\n\nwaffle\n华夫饼图绘制包，使用方法可见使用 waffle package 制作华夫饼图。\n\n\nggalluvial\n桑基图和凹凸图绘制包，使用方法可见使用 ggalluvial 制作桑基图和凹凸图。\n\n\nggwordcloud\n用 ggplot 语法绘制词云，使用方法可见 ggwordcloud: a word cloud geom for ggplot2 及 R Charts: Word cloud in ggplot2 with ggwordcloud。"
  },
  {
    "objectID": "posts/常用包和函数汇总/index.html#字体处理",
    "href": "posts/常用包和函数汇总/index.html#字体处理",
    "title": "R 常用包和函数汇总",
    "section": "字体处理",
    "text": "字体处理\n\nsystemfonts 和 showtext\n在作图时找到中文字体对应的英文名，并渲染中文字体，使用方法可见作图时如何正确渲染中文字体。\n\n\nggtext\n在 ggplot2 中，提供了额外的富文本使用方法（例如HTML和CSS格式的文本），可以更加灵活地格式化标签、标题和其他文本，用法可见文档。\n\n\nggfittext\n可以自动调整文本大小，以适应图形布局，当需要处理密集的图形和标签时较为有用。用法可见文档。"
  },
  {
    "objectID": "posts/常用包和函数汇总/index.html#其他数据可视化组件",
    "href": "posts/常用包和函数汇总/index.html#其他数据可视化组件",
    "title": "R 常用包和函数汇总",
    "section": "其他数据可视化组件",
    "text": "其他数据可视化组件\n\nhrbrthemes\nggplot 主题风格拓展，使用方法可见 hrbrthemes：最好用的 ggplot 主题扩展包。\n\n\ngghighlight\n帮助高亮图表，使用方法可见使用 gghighlight 制图。\n\n\npatchwork\n快速组合不同图表：p1 + p2。使用方法详见教程。"
  }
]